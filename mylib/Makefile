# "Фиктивные" цели
.PHONY: all clean

# Объектные файлы, собираемые в статическую библиотеку
OBJS= bst.o

# Файл библиотеки
# Действует соглашение: файл библиотеки <mylib> имеет имя lib<mylib>.a
MYLIBNAME= libmylib.a

# Чтобы достичь цели "all", требуется построить библиотеку
all: $(MYLIBNAME)

# Чтобы достичь цели "clean", требуется удалить созданные при сборке файлы
# - объектные файлы (bst.o)
# - файлы зависимостей (bst.d)
# - файл библиотеки (libmylib.a)
clean:
	$(RM) -f $(OBJS)
	$(RM) -f $(OBJS:.o=.d)
	$(RM) -f $(MYLIBNAME)


# Параметры компиляции
CFLAGS= -std=c11 -pedantic -Wall -Wextra
# Прибавим к имеющимся параметрам "-O1"
CFLAGS+= -O1

# Включаемые файлы следует искать в каталоге "include"
INCLUDES+= -I ./include

# Make должна искать файлы *.h в каталогах include и src
vpath %.h include src
# ..., а файлы *.c - в каталоге src
vpath %.c src

# Рецепт построения файла библиотеки из имеющихся объектных файлов
# значением переменной $@ будет имя файла библиотеки
# значением переменной $^ будет список (с пробелом в качестве символа-разделителя) зависимостей
#     (с удаленными дубликатами), в данном случае - список объектных файлов
$(MYLIBNAME): $(OBJS)
	$(AR) -rsc $@ $^

# Рецепт построения объектного файла из исходного текста
# значением переменной $< будет имя первого файла в списке зависимостей, в данном случае - имя исходного файла
%.o: %.c
	gcc -MD $(CFLAGS) $(INCLUDES) -c -o $@ $<

# Включаем всю имеющуюся информацию о зависимостях
# Лидирующий "-" означает, что отсутствие файла .d не является ошибкой
-include $(OBJS:.o=.d)
